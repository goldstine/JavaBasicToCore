package org.goldstine.net01.BS;

/**
 * 基本通信模型的介绍
 * （1）BIO通信模式：同步阻塞时通信,服务器实现模式为一个连接一个线程
 * 即客户端有连接请求时，服务端就需要启动一个线程进行处理
 * 如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善
 *
 * （2）伪异步通信，引入了线程池
 * 不需要一个客户一个线程，可以实现1个线程复用来处理很多个客户端
 * 这种架构，可以避免系统的死机，因为不会出现很多的线程，线程可控
 *
 * 但是高并发下性能还是很差：a:线程数量少，数据依然是阻塞的，数据没有多余的线程还是要阻塞
 *
 * （3）NIO表示同步非阻塞式通信，服务器实现模式为一个请求一个线程
 * 即客户端发送的连接请求都会注册到多路复用器上
 * 多路复用器轮询到连接有IO请求时才启动一个线程进行处理
 *
 * 1个人专门负责接收客户端：
 * 1个人[c1,c2,c3,c4,c4...]轮询所有的客户端，发来了数据才会开启线程处理
 * 这种架构性能还可以
 * 同步：线程还是要不断地接收客户端连接，以及处理数据
 * 非阻塞：如果一个管道没有数据，不需要等待，可以轮询下一个管道是否有数据
 *
 * 只需要开始一个线程接受无数个客户端，在开启一个线程负责轮询所有的客户端是否有数据，有数据才开启一个线程处理它
 *
 * （4）AIO异步非阻塞IO  服务器实现模式为一个有效请求一个线程
 * 客户端的IO请求都是由操作系统先完成IO操作后再通知服务器应用来启动线程来进行处理
 *异步：服务端线程接收到了客户端管道之后就交给底层处理他的io通信
 * 自己可以做其他事情
 *
 * 非阻塞：底层也是客户端有数据才会处理，有了数据以后处理好通知服务器应用来启动线程继续进行处理
 *
 *小结：各种模型应用场景：
 * BIO适用于连接数目比较小且固定的架构，该方式对服务器资源要求比较高，JDK1.4以前唯一的选择
 * NIO适用于连接数目多且连接比较短（轻操作）的架构，如聊天服务器，编程复杂
 *      JDK1.4开始支持
 *                      因为如果连接比较长，会导致NIO的轮询时间开销比较大
 *   AIO适用于连接数目较多且连接比较长（重操作）的架构，如相册服务器
 *   充分调用操作系统参与并发操作，编程复杂，JDK1.7开始支持
 *
 *
 * 进一步小结：
 * UDP无连接，基于数据包，发出去就不管了，性能好，可能丢失数据
 * TCP面向连接的，基于通信管道，字节流，可靠传输
 *
 */
public class NioDemo {
    public static void main(String[] args) {

    }
}
